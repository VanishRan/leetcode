//
//  149直线上最多的点数.cpp
//  RanLeetCode
//
//  Created by mahuanran on 2020/9/3.
//  Copyright © 2020 mahuanran. All rights reserved.
//

#include "common.h"

/*
 当确定一个点后，平面上的其他点都和这个点可以求出一个斜率，斜率相同的点就意味着在同一条直线上。

 所以我们可以用 HashMap 去计数，斜率作为 key，然后遍历平面上的其他点，相同的 key 意味着在同一条直线上。

 上边的思想解决了「经过某个点的直线，哪条直线上的点最多」的问题。接下来只需要换一个点，然后用同样的方法考虑完所有的点即可。

 当然还有一个问题就是斜率是小数，怎么办。

 之前提到过了，我们用分数去表示，求分子分母的最大公约数，然后约分，最后将 「分子 + "@" + "分母"」作为 key 即可。

 最后还有一个细节就是，当确定某个点的时候，平面内如果有和这个重叠的点，如果按照正常的算法约分的话，会出现除 0 的情况，所以我们需要单独用一个变量记录重复点的个数，而重复点一定是过当前点的直线的。
 
 */

//求斜率
class Solution {
public:
    int maxPoints(vector<vector<int>>& points) {
        return 0;
    }
};

/*
 给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。

 示例 1:

 输入: [[1,1],[2,2],[3,3]]
 输出: 3
 解释:
 ^
 |
 |        o
 |     o
 |  o
 +------------->
 0  1  2  3  4
 示例 2:

 输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
 输出: 4
 解释:
 ^
 |
 |  o
 |     o        o
 |        o
 |  o        o
 +------------------->
 0  1  2  3  4  5  6

 来源：力扣（LeetCode）
 链接：https://leetcode-cn.com/problems/max-points-on-a-line
 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */
